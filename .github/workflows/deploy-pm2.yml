name: Deploy MarinaObuv with PM2

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set workflow title
        run: |
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          echo "workflow_title=$COMMIT_MSG" >> $GITHUB_OUTPUT
        id: set_title

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Install dependencies
        run: |
          npm install
          cd web && npm install
          # Install Playwright Chromium browser for aggregator parser (for build/test)
          echo "üé≠ Installing Playwright Chromium browser..."
          npm run playwright:install:ci || echo "‚ö†Ô∏è Playwright install failed, but continuing with build"

      - name: Run linting
        run: |
          cd web && npm run lint:check

      - name: Run type checking
        run: |
          cd web && npm run typecheck

      - name: Run tests (if any)
        run: |
          cd web
          npm run build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_SITE_URL: https://marina-obuv.ru
          NEXT_PUBLIC_BRAND_NAME: MarinaObuv
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_URL: https://marina-obuv.ru
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}

      - name: Delete all existing artifacts (pre-clean)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üßπ Deleting all existing artifacts to free storage..."
          ids=$(gh api repos/${{ github.repository }}/actions/artifacts --paginate --jq '.artifacts[].id' || echo "")
          if [ -n "$ids" ]; then
            for id in $ids; do
              echo "Deleting artifact $id"
              gh api repos/${{ github.repository }}/actions/artifacts/$id -X DELETE || true
            done
          else
            echo "No artifacts to delete."
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            web/.next/
            web/package*.json
            web/node_modules/
            web/prisma/
            web/public/
            web/src/
            web/next.config.ts
            web/tsconfig.json
            web/postcss.config.mjs
            web/tailwind.config.ts
            web/.env*
          retention-days: 1

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 60
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Cancel previous deployments
        run: |
          echo "üõë Cancelling all previous workflow runs..."
          gh api repos/${{ github.repository }}/actions/runs --jq '.workflow_runs[] | select(.status == "in_progress" and .id != ${{ github.run_id }}) | .id' | xargs -I {} gh api repos/${{ github.repository }}/actions/runs/{}/cancel -X POST || echo "No previous runs to cancel"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for cancellations
        run: |
          echo "‚è≥ Waiting for previous runs to be cancelled..."
          sleep 15
          echo "‚úÖ Ready to proceed with new deployment"

      - name: Cancel previous deployments (backup)
        uses: nick-invision/retry@v2
        with:
          timeout_minutes: 10
          max_attempts: 5
          command: |
            echo "üîÑ Checking for previous deployments to cancel..."

            # Get all in-progress workflow runs for this repository
            RUNS=$(gh api repos/${{ github.repository }}/actions/runs --jq '.workflow_runs[] | select(.status == "in_progress" and .id != ${{ github.run_id }}) | .id')

            if [ ! -z "$RUNS" ]; then
              echo "üõë Found previous deployments to cancel: $RUNS"
              for run_id in $RUNS; do
                echo "üõë Cancelling deployment run: $run_id"
                gh api repos/${{ github.repository }}/actions/runs/$run_id/cancel -X POST || echo "Failed to cancel run $run_id"
                sleep 2
              done

              # Wait a bit for cancellations to take effect
              echo "‚è≥ Waiting for cancellations to take effect..."
              sleep 10

              # Check if any are still running
              REMAINING=$(gh api repos/${{ github.repository }}/actions/runs --jq '.workflow_runs[] | select(.status == "in_progress" and .id != ${{ github.run_id }}) | .id')
              if [ ! -z "$REMAINING" ]; then
                echo "‚ö†Ô∏è Some deployments are still running: $REMAINING"
                echo "üîÑ Attempting force cancellation..."
                for run_id in $REMAINING; do
                  gh api repos/${{ github.repository }}/actions/runs/$run_id/cancel -X POST || echo "Force cancel failed for run $run_id"
                done
              else
                echo "‚úÖ All previous deployments cancelled successfully"
              fi
            else
              echo "‚úÖ No previous deployments found to cancel"
            fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout code
        uses: actions/checkout@v4

      # Skip artifact download: we rebuild on server to avoid stale/overwriting files
      # - name: Download build artifacts
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: build-artifacts
      #     path: web/

      - name: Setup Node.js (for server deployment tools)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Test SSH Connection
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 30s
          command_timeout: 30s
          debug: true
          use_insecure_cipher: false
          cipher: aes128-ctr,aes192-ctr,aes256-ctr
          script: |
            echo "üîç Testing SSH connection..."
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "Server info: $(uname -a)"
            echo "‚úÖ SSH connection successful!"

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 1200s
          command_timeout: 1800s
          debug: true
          use_insecure_cipher: false
          cipher: aes128-ctr,aes192-ctr,aes256-ctr
          script: |
            set -e
            # Check if application directory exists
            if [ ! -d "/var/www/marinaobuv" ]; then
                echo "Setting up application directory..."
                sudo mkdir -p /var/www/marinaobuv
                sudo chown -R $USER:$USER /var/www/marinaobuv
                git clone https://github.com/singladno/marinaobuv.git /var/www/marinaobuv
            fi

            # Navigate to application directory
            cd /var/www/marinaobuv

            # Force-refresh repository to avoid untracked/dirty tree issues
            echo "üîÅ Refreshing repository from origin/main..."
            git fetch origin main
            # Backup untracked files list for debugging
            echo "üìã Untracked files before cleanup:" || true
            git ls-files --others --exclude-standard || true
            # Discard local changes and untracked files, then reset to origin/main
            git reset --hard origin/main
            git clean -fd
            echo "‚úÖ Repository reset to origin/main"

            # Ensure all scripts are executable
            echo "üîß Setting execute permissions for all scripts..."
            chmod +x scripts/*.sh 2>/dev/null || echo "No scripts found in scripts directory"
            chmod +x web/src/scripts/*.sh 2>/dev/null || echo "No scripts found in web/src/scripts directory"
            echo "‚úÖ Script permissions set"


            # Verify critical scripts exist
            echo "üîç Verifying critical scripts exist..."
            if [ -f "scripts/verify-webhook-deployment.sh" ]; then
              echo "‚úÖ Webhook verification script found"
            else
              echo "‚ùå CRITICAL: Webhook verification script not found!"
              echo "Available files in scripts directory:"
              ls -la scripts/ || echo "No scripts directory found"
              echo "üí° DEPLOYMENT FAILED - required script missing"
              exit 1
            fi

            # Use existing environment file instead of GitHub Secrets
            echo "üîß Using environment file for configuration..."
            if [ -f "web/.env" ]; then
                echo "‚úÖ Found existing .env file"
            elif [ -f "web/env.example" ]; then
                echo "üìã Using env.example as template for environment"
                cp web/env.example web/.env
                echo "‚ö†Ô∏è Please update web/.env with your actual values!"
            else
                echo "‚ùå No environment file found!"
                echo "Please ensure web/.env or web/env.example exists"
                exit 1
            fi

            # Show which env keys are present (names only)
            echo "Env keys on server:" && cut -d= -f1 web/.env | paste -sd, -

            # Ensure database is properly initialized
            echo "üóÑÔ∏è Initializing database configuration..."

            # Check if PostgreSQL is running
            if ! systemctl is-active --quiet postgresql; then
              echo "üîß Starting PostgreSQL service..."
              sudo systemctl start postgresql
              sudo systemctl enable postgresql
            fi

            # Load DATABASE_URL from environment file safely
            echo "üîß Loading environment variables safely..."
            set -a  # automatically export all variables
            # Process the .env file line by line, handling quotes properly
            while IFS= read -r line || [ -n "$line" ]; do
                # Skip empty lines and comments
                if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                    continue
                fi

                # Extract key and value, handling quotes properly
                if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
                    key="${BASH_REMATCH[1]}"
                    value="${BASH_REMATCH[2]}"

                    # Remove surrounding quotes if they exist and match
                    if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                        value="${BASH_REMATCH[1]}"
                    fi

                    # Export the variable
                    export "$key"="$value"
                fi
            done < web/.env
            set +a  # turn off automatic export

            # Verify database connection string is valid
            if [ -z "$DATABASE_URL" ]; then
              echo "‚ùå DATABASE_URL is not set in environment file!"
              echo "Available environment variables:"
              cat web/.env | grep -v '^#' | head -10
              exit 1
            fi

            # Skip database setup (managed manually outside deploy)
            echo "‚ÑπÔ∏è Skipping database setup (handled manually)"

            # Test database connection
            echo "üîç Testing database connection..."
            cd web && ./prisma-server.sh npx prisma db pull --print > /dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "‚ö†Ô∏è Database connection test failed, but continuing with deployment..."
            else
              echo "‚úÖ Database connection verified"
            fi
            cd ..

            # Skip DB auth modification during deploy
            echo "‚ÑπÔ∏è Skipping DB auth modification during deploy"

            # Install dependencies including dev (required for tsx/typescript used by scripts)
            cd web && npm ci
            # Install Playwright Chromium browser for aggregator parser
            echo "üé≠ Installing Playwright Chromium browser..."
            npm run playwright:install:ci || echo "‚ö†Ô∏è Playwright install failed, aggregator parser may be unavailable"
            cd ..

            # Note: Proxy runs on separate serverspace server
            echo "üìã Note: Proxy server runs on separate serverspace server (31.44.2.216)"

            # Generate Prisma client with proper environment
            cd web
            echo "üîß Generating Prisma client..."
            ./prisma-server.sh npm run prisma:generate

            # Verify Prisma client was generated
            if [ ! -f "node_modules/@prisma/client/index.js" ]; then
              echo "‚ùå Prisma client not generated properly!"
              echo "üîß Attempting to regenerate..."
              ./prisma-server.sh npx prisma generate
              if [ ! -f "node_modules/@prisma/client/index.js" ]; then
                echo "‚ùå CRITICAL: Prisma client generation failed!"
                exit 1
              fi
            fi
            echo "‚úÖ Prisma client generated successfully"

            # Verify database connection
            echo "üîç Verifying database connection..."
            ./prisma-server.sh npx prisma db pull --print || echo "‚ö†Ô∏è Database connection test failed, but continuing..."

            # Skip backup (requires tsx); do backups manually or on cron
            echo "‚ÑπÔ∏è Skipping DB backup during deploy"

            # Skip database permission changes during deploy to avoid YAML/heredoc issues
            echo "‚ÑπÔ∏è Skipping database permission adjustments during deployment"

            # Run database migrations with comprehensive error handling
            echo "üöÄ Running database migrations with conflict resolution..."

            # First, try to resolve any failed migrations
            echo "üîß Checking for failed migrations and resolving conflicts..."
            ./prisma-server.sh npx prisma migrate resolve --applied 20250120000000_add_order_number_sequence 2>/dev/null || echo "Migration already resolved or doesn't exist"
            ./prisma-server.sh npx prisma migrate resolve --applied 20250120000001_update_order_statuses 2>/dev/null || echo "Migration already resolved or doesn't exist"
            ./prisma-server.sh npx prisma migrate resolve --applied 20250120000002_remove_ord_prefix 2>/dev/null || echo "Migration already resolved or doesn't exist"
            ./prisma-server.sh npx prisma migrate resolve --applied 20250120000003_update_order_status_default 2>/dev/null || echo "Migration already resolved or doesn't exist"
            ./prisma-server.sh npx prisma migrate resolve --applied 20250120000004_add_order_item_sequence 2>/dev/null || echo "Migration already resolved or doesn't exist"
            ./prisma-server.sh npx prisma migrate resolve --applied 20250916211900_init 2>/dev/null || echo "Migration already resolved or doesn't exist"

            # Try to run migrations
            if ./prisma-server.sh npx prisma migrate deploy; then
              echo "‚úÖ Database migrations completed successfully"
            else
              echo "‚ùå Database migrations failed, attempting schema synchronization..."
              if ./prisma-server.sh npx prisma db push --accept-data-loss; then
                echo "‚úÖ Database schema synchronized successfully"
              else
                echo "‚ùå CRITICAL: Database schema synchronization failed!"
                echo "üí° DEPLOYMENT FAILED - could not fix database schema"
                exit 1
              fi

            # Ensure default categories exist (critical for parser functionality)
            echo "üîß Ensuring default categories exist..."
            ./prisma-server.sh npx prisma db execute --stdin <<< "
              INSERT INTO \"Category\" (id, name, slug, description, \"createdAt\", \"updatedAt\")
              VALUES ('default', '–û–±—É–≤—å', 'obuv', '–û—Å–Ω–æ–≤–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –æ–±—É–≤–∏', NOW(), NOW())
              ON CONFLICT (id) DO NOTHING;

              INSERT INTO \"Category\" (id, name, slug, description, \"createdAt\", \"updatedAt\")
              VALUES ('winter', '–ó–∏–º–Ω—è—è –æ–±—É–≤—å', 'winter-shoes', '–ó–∏–º–Ω—è—è –æ–±—É–≤—å –∏ –∞–∫—Å–µ—Å—Å—É–∞—Ä—ã', NOW(), NOW())
              ON CONFLICT (id) DO NOTHING;

              INSERT INTO \"Category\" (id, name, slug, description, \"createdAt\", \"updatedAt\")
              VALUES ('summer', '–õ–µ—Ç–Ω—è—è –æ–±—É–≤—å', 'summer-shoes', '–õ–µ—Ç–Ω—è—è –æ–±—É–≤—å –∏ —Å–∞–Ω–¥–∞–ª–∏–∏', NOW(), NOW())
              ON CONFLICT (id) DO NOTHING;
            " 2>/dev/null || echo "Categories already exist or table doesn't exist yet"
            echo "‚úÖ Default categories ensured"
            fi

            # Skip init/seed (requires tsx); run manually when needed
            echo "‚ÑπÔ∏è Skipping DB init/seed during deploy"
            cd ..

            # Build application (blue-green deployment will handle PM2)
            echo "üîß Building application..."
            cd web
            # Ensure path alias '@' resolves during build
            if ! grep -q '"baseUrl"' tsconfig.json; then
              jq '.compilerOptions.baseUrl = "."' tsconfig.json > tsconfig.tmp && mv tsconfig.tmp tsconfig.json
            fi
            # Clear old app logs to avoid confusing tail output later
            mkdir -p logs
            : > logs/marinaobuv-error.log || true
            : > logs/marinaobuv-out.log || true
            npm ci
            # Ensure Playwright Chromium browser is installed for aggregator parser
            echo "üé≠ Ensuring Playwright Chromium browser is installed..."
            npm run playwright:install:ci || echo "‚ö†Ô∏è Playwright install failed, aggregator parser may be unavailable"
            npm run build
            cd ..
            echo "‚úÖ Server-side build completed"

            # Ensure production build exists
            if [ ! -f "web/.next/BUILD_ID" ]; then
              echo "‚ùå Build artifact missing (.next/BUILD_ID not found)"
              ls -la web/.next || true
              exit 1
            fi

            # Setup HTTPS and nginx configuration
            echo "üîí Setting up HTTPS and nginx configuration..."

            # Install required packages for HTTPS
            export DEBIAN_FRONTEND=noninteractive
            timeout 300 sudo apt-get update || echo "‚ö†Ô∏è apt-get update timed out"
            timeout 600 sudo apt-get install -y certbot python3-certbot-nginx openssl || echo "‚ö†Ô∏è Package install timed out"

            # Create SSL directory structure
            sudo mkdir -p /etc/ssl/certs
            sudo mkdir -p /etc/ssl/private
            sudo chmod 755 /etc/ssl/certs
            sudo chmod 700 /etc/ssl/private

            # Generate SSL certificate if not exists
            if [ ! -f "/etc/ssl/certs/marinaobuv.ru.crt" ]; then
              echo "üîê Generating SSL certificate..."
              sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout /etc/ssl/private/marinaobuv.ru.key \
                  -out /etc/ssl/certs/marinaobuv.ru.crt \
                  -subj "/C=RU/ST=Moscow/L=Moscow/O=MarinaObuv/OU=IT/CN=marina-obuv.ru"

              sudo chmod 600 /etc/ssl/private/marinaobuv.ru.key
              sudo chmod 644 /etc/ssl/certs/marinaobuv.ru.crt
            else
              echo "‚úÖ SSL certificate already exists"
            fi

            # Add rate limiting zones to main nginx.conf
            echo "‚öôÔ∏è Adding rate limiting zones to nginx.conf..."
            if ! grep -q "limit_req_zone.*api" /etc/nginx/nginx.conf; then
              sudo sed -i '/http {/a\    # Rate limiting zones\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;' /etc/nginx/nginx.conf
            fi

            # Fix nginx configuration first
            echo "üîß Fixing nginx configuration..."
            if [ -f "scripts/fix-nginx-config.sh" ]; then
              chmod +x scripts/fix-nginx-config.sh
              if ./scripts/fix-nginx-config.sh; then
                echo "‚úÖ Nginx configuration fixed successfully"
              else
                echo "‚ùå Failed to fix nginx configuration"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è Nginx fix script not found, using manual fix..."
              # Manual nginx configuration fix
              sudo tee /etc/nginx/conf.d/marinaobuv.conf > /dev/null << 'EOF'
            server {
                listen 80;
                server_name marina-obuv.ru www.marina-obuv.ru;

                location / {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }

                location /api/ {
                    proxy_pass http://localhost:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }

                location /health {
                    proxy_pass http://localhost:3000/api/health;
                    access_log off;
                }
            }
            EOF
            fi

            # HTTPS vhost is managed dynamically by blue-green script; skip static copy to avoid overwriting LE cert paths
            echo "‚ÑπÔ∏è Skipping static HTTPS vhost copy; managed by blue-green switch"

            # Setup Let's Encrypt certificate
            echo "üîê Setting up Let's Encrypt certificate..."
            timeout 180 sudo certbot --nginx -d marina-obuv.ru -d www.marina-obuv.ru --non-interactive --agree-tos --email admin@marina-obuv.ru || echo "‚ö†Ô∏è Let's Encrypt setup failed or timed out, using self-signed certificate"

            # Setup auto-renewal
            echo "üîÑ Setting up certificate auto-renewal..."
            (sudo crontab -l 2>/dev/null | grep -v certbot; echo "0 12 * * * /usr/bin/certbot renew --quiet --post-hook 'systemctl reload nginx'") | sudo crontab -

            # Configure firewall
            echo "üî• Configuring firewall..."
            timeout 60 sudo ufw allow 22/tcp || true
            timeout 60 sudo ufw allow 80/tcp || true
            timeout 60 sudo ufw allow 443/tcp || true
            timeout 60 sudo ufw --force enable || echo "‚ö†Ô∏è Firewall configuration failed or timed out"

            # Install/refresh server cron jobs from repository config
            echo "üïí Installing cron jobs from scripts/cron-jobs.conf..."
            if [ -f "scripts/install-crons.sh" ]; then
              chmod +x scripts/install-crons.sh
              cd /var/www/marinaobuv
              if bash scripts/install-crons.sh; then
                echo "‚úÖ Cron jobs installed successfully"

                # Verify webhook monitor cron is installed
                if crontab -l 2>/dev/null | grep -q "webhook-status-monitor"; then
                  echo "‚úÖ Webhook monitor cron job verified"
                else
                  echo "‚ö†Ô∏è Webhook monitor cron job not found in crontab"
                fi

                # Verify cron service is running
                if systemctl is-active --quiet cron || systemctl is-active --quiet crond; then
                  echo "‚úÖ Cron service is running"
                else
                  echo "‚ö†Ô∏è Cron service is not running"
                fi

                # Ensure logs directory exists for webhook monitor
                mkdir -p web/logs
                touch web/logs/webhook-monitor.log
                chmod 666 web/logs/webhook-monitor.log 2>/dev/null || true
                echo "‚úÖ Webhook monitor log file ready"
              else
                echo "‚ùå Cron installation failed!"
                echo "Attempting manual cron installation..."
                # Fallback: manually add webhook monitor cron if install script fails
                CRON_ENTRY="*/15 * * * * cd /var/www/marinaobuv/web && NODE_ENV=production [ \"\$DISABLE_CRON_WEBHOOK_MONITOR\" != \"true\" ] && /usr/bin/env ./node_modules/.bin/tsx src/scripts/webhook-status-monitor.ts >> /var/www/marinaobuv/web/logs/webhook-monitor.log 2>&1 # JOB:webhook-monitor"
                (crontab -l 2>/dev/null | grep -v "webhook-status-monitor"; echo "$CRON_ENTRY") | crontab -
                echo "‚úÖ Webhook monitor cron added manually"
              fi
            else
              echo "‚ùå Cron installation script not found!"
              echo "Available files in scripts directory:"
              ls -la scripts/ || echo "No scripts directory found"
            fi

            # Load runtime environment for PM2 safely
            echo "üîß Exporting environment for PM2 runtime..."
            set -a  # automatically export all variables
            # Process the .env file line by line, handling quotes properly
            while IFS= read -r line || [ -n "$line" ]; do
                # Skip empty lines and comments
                if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                    continue
                fi

                # Extract key and value, handling quotes properly
                if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
                    key="${BASH_REMATCH[1]}"
                    value="${BASH_REMATCH[2]}"

                    # Remove surrounding quotes if they exist and match
                    if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                        value="${BASH_REMATCH[1]}"
                    fi

                    # Export the variable
                    export "$key"="$value"
                fi
            done < web/.env
            set +a  # turn off automatic export

            # Use Blue-Green Zero-Downtime Deployment
            echo "üöÄ Starting Blue-Green Zero-Downtime Deployment..."
            if [ -f "scripts/blue-green-deploy.sh" ]; then
              chmod +x scripts/blue-green-deploy.sh
              if ./scripts/blue-green-deploy.sh; then
                echo "‚úÖ Blue-Green deployment completed successfully!"
              else
                echo "‚ùå Blue-Green deployment failed!"
                pm2 logs --lines 50
                exit 1
              fi
            else
              echo "‚ùå Blue-Green deployment script not found!"
              echo "Falling back to traditional deployment..."

              # Fallback to traditional deployment
              pm2 kill 2>/dev/null || true
              sleep 2
              pm2 start ecosystem.config.js --env production
              if [ $? -ne 0 ]; then
                echo "PM2 start failed!"
                pm2 logs marinaobuv --lines 50
                exit 1
              fi

              # Wait for application to start
              echo "Waiting for application to start..."
              sleep 15

              # Health check with retries
              for i in {1..5}; do
                echo "Health check attempt $i/5..."
                if curl -f http://localhost:3000/api/health; then
                  echo "Health check passed!"
                  break
                else
                  echo "Health check failed, attempt $i/5"
                  if [ $i -eq 5 ]; then
                    echo "Health check failed after 5 attempts"
                    pm2 logs marinaobuv --lines 50
                    exit 1
                  fi
                  sleep 5
                fi
              done
            fi

            # Save PM2 configuration
            pm2 save

            # Show status
            pm2 status

            # Database connectivity health check
            echo "üîç Testing database connectivity..."
            cd web
            ./prisma-server.sh npx prisma db pull --print > /dev/null 2>&1
            if [ $? -eq 0 ]; then
              echo "‚úÖ Database connectivity verified"
            else
              echo "‚ùå Database connectivity failed!"
              echo "üîß Attempting to fix database connection..."

              # Fix database authentication issues
              echo "üîß Fixing database authentication issues..."
              cd ..
              set -a  # automatically export all variables
              # Process the .env file line by line, handling quotes properly
              while IFS= read -r line || [ -n "$line" ]; do
                  # Skip empty lines and comments
                  if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                      continue
                  fi

                  # Extract key and value, handling quotes properly
                  if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
                      local key="${BASH_REMATCH[1]}"
                      local value="${BASH_REMATCH[2]}"

                      # Remove surrounding quotes if they exist and match
                      if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                          value="${BASH_REMATCH[1]}"
                      fi

                      # Export the variable
                      export "$key=$value"
                  fi
              done < web/.env
              set +a  # turn off automatic export
              ./scripts/fix-database-auth.sh

              # Test connection again
              cd web
              ./prisma-server.sh npx prisma db pull --print > /dev/null 2>&1
              if [ $? -eq 0 ]; then
                echo "‚úÖ Database connection restored"
              else
                echo "‚ùå Database connection could not be restored"
                echo "üîç Database connection details:"
                echo "Host: $DB_HOST"
                echo "Port: $DB_PORT"
                echo "Database: $DB_NAME"
                echo "User: $DB_USER"
                echo "üîç Testing direct PostgreSQL connection..."
                PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" || echo "Direct connection failed"
                pm2 logs marinaobuv --lines 50
                exit 1
              fi
            fi
            cd ..

            # Run comprehensive diagnostics (with timeout) if script exists
            echo "üîç Running comprehensive diagnostics..."
            if [ -f scripts/diagnose-domain-issues.sh ]; then
              chmod +x scripts/diagnose-domain-issues.sh
              timeout 60 ./scripts/diagnose-domain-issues.sh || echo "‚ö†Ô∏è Diagnostics completed with timeout"
            else
              echo "‚ÑπÔ∏è diagnose-domain-issues.sh not found, skipping"
            fi

            # Fix common hosting issues (with timeout) if script exists
            echo "üîß Fixing common hosting issues..."
            if [ -f scripts/fix-hosting-issues.sh ]; then
              chmod +x scripts/fix-hosting-issues.sh
              timeout 60 ./scripts/fix-hosting-issues.sh || echo "‚ö†Ô∏è Hosting fixes completed with timeout"
            else
              echo "‚ÑπÔ∏è fix-hosting-issues.sh not found, skipping"
            fi

            # CRITICAL: Final application health check
            echo "üîç Performing final application health check..."
            sleep 10  # Wait for application to fully start

            # Test database connectivity and schema
            echo "üîç Testing database schema..."
            cd web
            if ./prisma-server.sh npx prisma db execute --stdin <<< "SELECT \"analysisBatchId\" FROM \"Product\" LIMIT 1;" > /dev/null 2>&1; then
              echo "‚úÖ Database schema validation passed"
              cd ..
            else
              echo "‚ùå CRITICAL: Database schema is still broken!"
              echo "üîß Attempting final schema fix..."
              # Final attempt to fix schema
              cd web
              echo "Adding missing analysisBatchId column..."
              ./prisma-server.sh npx prisma db execute --stdin <<< "ALTER TABLE \"Product\" ADD COLUMN \"analysisBatchId\" TEXT;" || echo "Column may already exist"
              echo "Adding missing colorBatchId column..."
              ./prisma-server.sh npx prisma db execute --stdin <<< "ALTER TABLE \"Product\" ADD COLUMN \"colorBatchId\" TEXT;" || echo "Column may already exist"
              echo "Adding missing batchProcessingStatus column..."
              ./prisma-server.sh npx prisma db execute --stdin <<< "ALTER TABLE \"Product\" ADD COLUMN \"batchProcessingStatus\" TEXT DEFAULT 'pending';" || echo "Column may already exist"
              echo "Adding missing indexes..."
              ./prisma-server.sh npx prisma db execute --stdin <<< "CREATE UNIQUE INDEX IF NOT EXISTS \"Product_analysisBatchId_key\" ON \"Product\"(\"analysisBatchId\");" || echo "Index may already exist"
              ./prisma-server.sh npx prisma db execute --stdin <<< "CREATE UNIQUE INDEX IF NOT EXISTS \"Product_colorBatchId_key\" ON \"Product\"(\"colorBatchId\");" || echo "Index may already exist"
              echo "Regenerating Prisma client..."
              ./prisma-server.sh npm run prisma:generate
              cd ..
              echo "Restarting application..."
              pm2 restart marinaobuv
              sleep 10
              # Test again after fixes
              if ./prisma-server.sh npx prisma db execute --stdin <<< "SELECT \"analysisBatchId\" FROM \"Product\" LIMIT 1;" > /dev/null 2>&1; then
                echo "‚úÖ Database schema fixed successfully"
              else
                echo "‚ùå CRITICAL: Database schema could not be fixed!"
                echo "üí° DEPLOYMENT FAILED - application will not work"
                exit 1
              fi
            fi

            # Test application endpoints (via Nginx, not direct Node port)
            echo "üîç Testing application endpoints via Nginx..."
            HEALTH_OK=false
            for i in {1..5}; do
              if curl -f -s http://localhost/api/health > /dev/null 2>&1 || \
                 curl -f -s https://marina-obuv.ru/api/health > /dev/null 2>&1; then
                HEALTH_OK=true
                break
              fi
              echo "‚è≥ Nginx health check retry $i/5..."
              sleep 3
            done
            if [ "$HEALTH_OK" = true ]; then
              echo "‚úÖ Health endpoint working via Nginx"
            else
              echo "‚ùå CRITICAL: Health endpoint failed via Nginx!"
              echo "üí° DEPLOYMENT FAILED - application is not responding through the reverse proxy"
              exit 1
            fi

            # Remove unused tinyproxy Docker container to free up port 8888 and resources
            echo "üßπ Removing unused tinyproxy Docker container..."
            docker stop tinyproxy 2>/dev/null || true
            docker rm tinyproxy 2>/dev/null || true
            echo "‚úÖ Tinyproxy container removed (was not used by application)"

            echo "‚ÑπÔ∏è Skipping HTTP vhost rewrite; managed dynamically by blue-green switch to point at active port"

            # Verify webhook deployment
            echo "üîç Verifying webhook deployment..."

            # Check if webhook script exists and make it executable
            if [ -f "scripts/verify-webhook-deployment.sh" ]; then
              chmod +x scripts/verify-webhook-deployment.sh
              echo "‚úÖ Webhook verification script found and made executable"

              if ./scripts/verify-webhook-deployment.sh; then
                echo "‚úÖ Webhook verification completed successfully"
              else
                echo "‚ùå CRITICAL: Webhook verification failed!"
                echo "üí° DEPLOYMENT FAILED - webhook is not working"
                exit 1
              fi
            else
              echo "‚ùå CRITICAL: Webhook verification script not found!"
              echo "Available scripts:"
              ls -la scripts/ || echo "No scripts directory found"
              echo "üí° DEPLOYMENT FAILED - webhook script missing"
              exit 1
            fi

            # Verify webhook status monitor and Telegram configuration
            echo "üîç Verifying webhook status monitor configuration..."
            cd web

            # Check if Telegram environment variables are set (warn if not, but don't fail)
            if grep -q "TELEGRAM_BOT_TOKEN" .env 2>/dev/null && grep -q "TELEGRAM_CHAT_IDS" .env 2>/dev/null; then
              TELEGRAM_TOKEN=$(grep "^TELEGRAM_BOT_TOKEN=" .env | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)
              TELEGRAM_CHAT_IDS=$(grep "^TELEGRAM_CHAT_IDS=" .env | cut -d'=' -f2 | tr -d '"' | tr -d "'" | xargs)

              if [ -n "$TELEGRAM_TOKEN" ] && [ "$TELEGRAM_TOKEN" != "your_telegram_bot_token" ] && \
                 [ -n "$TELEGRAM_CHAT_IDS" ] && [ "$TELEGRAM_CHAT_IDS" != "123456789" ]; then
                echo "‚úÖ Telegram configuration found in .env"

                # Test webhook monitor script (dry run - just check it can load)
                echo "üß™ Testing webhook status monitor script..."
                if timeout 30 ./node_modules/.bin/tsx src/scripts/webhook-status-monitor.ts 2>&1 | head -20; then
                  echo "‚úÖ Webhook status monitor script is executable and loads correctly"
                else
                  echo "‚ö†Ô∏è Webhook status monitor script test had issues (may be normal if WhatsApp is down)"
                fi
              else
                echo "‚ö†Ô∏è Telegram environment variables are set but appear to be placeholder values"
                echo "   Please update TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_IDS in web/.env"
                echo "   See web/TELEGRAM_SETUP.md for setup instructions"
              fi
            else
              echo "‚ö†Ô∏è Telegram environment variables not found in .env"
              echo "   Webhook monitor will not send notifications until Telegram is configured"
              echo "   See web/TELEGRAM_SETUP.md for setup instructions"
            fi
            cd ..

            # Final status check
            echo "üìä Final deployment status:"
            echo "PM2 Status:"
            pm2 status
            echo ""
            echo "Nginx Status:"
            sudo systemctl status nginx --no-pager -l
            echo ""
            echo "Port 3000 Status:"
            netstat -tlnp | grep :3000 || echo "Port 3000 not listening"
            echo ""
            echo "Nginx Configuration Test:"
            sudo nginx -t
            echo ""
            echo "Cron Jobs Status:"
            if systemctl is-active --quiet cron || systemctl is-active --quiet crond; then
              echo "‚úÖ Cron service is running"
              echo "Installed cron jobs:"
              crontab -l 2>/dev/null | grep -E "(webhook-monitor|JOB:)" || echo "No managed cron jobs found"
            else
              echo "‚ö†Ô∏è Cron service is not running"
            fi
            echo ""
            echo "Webhook Monitor Log (last 5 lines):"
            tail -n 5 web/logs/webhook-monitor.log 2>/dev/null || echo "Log file not found or empty"
            echo ""
            echo "Domain Test (HTTPS):"
            timeout 30 curl -f https://marina-obuv.ru/api/health || echo "HTTPS domain access failed"
            echo "Domain Test (HTTP redirect):"
            timeout 30 curl -f http://marina-obuv.ru/api/health || echo "HTTP redirect test failed"
            echo "Webhook Test:"
            timeout 30 curl -f https://marina-obuv.ru/api/webhooks/green-api || echo "Webhook endpoint test failed"

            echo ""
            echo "üéâ Deployment completed successfully!"
            echo "‚úÖ Application is running on port 3000"
            echo "‚úÖ HTTPS is configured and working"
            echo "‚úÖ Nginx is properly configured"
            echo "‚úÖ PM2 is managing the application"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
          else
            echo "‚ùå Deployment failed!"
          fi

  deploy-proxy:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy proxy server to serverspace
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROXY_SSH_HOST }}
          username: ${{ secrets.PROXY_SSH_USER }}
          key: ${{ secrets.PROXY_SSH_PRIVATE_KEY }}
          port: ${{ secrets.PROXY_SSH_PORT }}
          timeout: 300s
          command_timeout: 300s
          debug: true
          script: |
            echo "üöÄ Starting proxy server deployment on serverspace..."

            # Create proxy directory if it doesn't exist
            mkdir -p /root/proxy

            # Stop and remove any existing groq-proxy processes
            echo "üõë Stopping existing groq-proxy processes..."
            pm2 stop groq-proxy 2>/dev/null || true
            pm2 delete groq-proxy 2>/dev/null || true

            # Kill any processes using port 8787
            echo "üîç Checking for port conflicts on port 8787..."
            if lsof -i :8787 >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  Port 8787 is in use, killing existing processes..."
                lsof -ti :8787 | xargs kill -9 2>/dev/null || true
                sleep 2
            fi

            # Copy proxy server files from git
            echo "üìÅ Setting up proxy server files..."
            cd /root
            if [ -d "proxy-backup" ]; then
                rm -rf proxy-backup
            fi
            if [ -d "proxy" ]; then
                mv proxy proxy-backup
            fi

            # Clone the repository to get the latest proxy files
            git clone https://github.com/singladno/marinaobuv.git temp-repo
            cp -r temp-repo/proxy /root/
            rm -rf temp-repo

            # Set proper permissions
            chmod +x /root/proxy/server.js

            # Install dependencies
            echo "üì¶ Installing proxy server dependencies..."
            cd /root/proxy
            npm install --production

            # Start the proxy server with PM2
            echo "üöÄ Starting groq-proxy with PM2..."
            PORT=8787 pm2 start server.js --name groq-proxy --env production

            # Save PM2 configuration
            pm2 save

            # Wait for server to start
            echo "‚è≥ Waiting for proxy server to start..."
            sleep 5

            # Test the proxy server
            echo "üß™ Testing proxy server..."
            if curl -f http://localhost:8787/healthz >/dev/null 2>&1; then
                echo "‚úÖ Proxy server is running successfully!"
                echo "üìä Proxy server status:"
                pm2 status groq-proxy
            else
                echo "‚ùå Proxy server failed to start!"
                echo "üìã Proxy server logs:"
                pm2 logs groq-proxy --lines 10
                exit 1
            fi

            echo "üéâ Proxy server deployment completed successfully!"
            echo "‚úÖ Proxy server is running on port 8787"
            echo "‚úÖ PM2 is managing the proxy server"
